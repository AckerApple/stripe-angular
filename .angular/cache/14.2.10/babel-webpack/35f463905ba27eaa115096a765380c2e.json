{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.simpleMenuToSmart = exports.simpleRouteToSmart = void 0;\n\nconst core_1 = require(\"@angular/core\");\n\nconst app_component_utils_1 = require(\"./app.component.utils\");\n\nfunction paramRouteId(routeRef) {\n  const typed = routeRef;\n  return typed._id = typed._id || performance.now();\n}\n\nfunction simpleRouteToSmart(route, allGroups) {\n  let routeRef = route; // first thing, make sure an export id reference is available (even if api is just a reference to another api it needs a unique _id)\n\n  paramRouteId(routeRef);\n\n  if (routeRef.$api) {\n    const targetApi = routeRef.$api(); // linkage details\n\n    routeRef._api = {\n      knownTitle: targetApi.title,\n      _id: paramRouteId(targetApi),\n      original: routeRef // save for edit/export purpose (we do not edit/export this newly created route, only the original gets edited/exported)\n\n    };\n    routeRef = Object.assign(Object.assign({}, targetApi), routeRef);\n  } // todo: need to add support for routeRef._api reference (will come in json)\n\n\n  if (routeRef.smarts && routeRef.smarts.smartAt) {\n    return routeRef; // already has been made smart\n  }\n\n  if (routeRef.data && routeRef.examples) {\n    routeRef.examples.push({\n      title: 'original data',\n      data: routeRef.data\n    });\n  }\n\n  if (routeRef.request) {\n    paramRequestUrlParams(routeRef.request);\n  }\n\n  routeRef.smarts = routeRef.smarts || newSmarts();\n\n  if (routeRef.smarts.smartAt) {\n    return routeRef;\n  }\n\n  routeRef.smarts.smartAt = performance.now(); // runtime tie memory paste-able data points\n\n  if (routeRef.pastes) {\n    routeRef.smarts.pastes = smartPastes(routeRef.pastes, routeRef, allGroups);\n  }\n\n  return routeRef;\n}\n\nexports.simpleRouteToSmart = simpleRouteToSmart;\n\nfunction newSmarts() {\n  return {\n    pastes: [],\n    related: [],\n    runtimeMessages: [],\n    $result: new core_1.EventEmitter(),\n    $send: new core_1.EventEmitter(),\n    load: 0\n  };\n}\n\nfunction smartPastes(pastes, api, allGroups) {\n  return pastes.map((paste, index) => {\n    const newPaste = JSON.parse(JSON.stringify(paste));\n    let pasteApi = paste.api; // lookup by identifier\n\n    if (paste._api) {\n      pasteApi = newPaste.api = findApiByIdInGroups(paste._api._id, allGroups);\n    } // TODO: deprecate this in-favor of named references\n\n\n    if (paste.$api) {\n      pasteApi = newPaste.api = paste.$api();\n\n      if (!pasteApi) {\n        const msg = `could not populate api paste ${index}: ${api.title}`;\n        throw new Error(msg);\n      }\n\n      delete paste.$api;\n    }\n\n    makePasteSmart(newPaste);\n\n    if (!pasteApi) {\n      pasteApi = newPaste.api = api; // its a self ref paste\n    } // relating apis by pastes\n\n\n    const selfReferencing = pasteApi === api;\n\n    if (!selfReferencing) {\n      paste._api = {\n        _id: pasteApi._id || (pasteApi._id = performance.now()),\n        knownTitle: pasteApi.title\n      }; // find the group this api belongs to for icon title purposes\n\n      const group = findApiGroup(allGroups, api);\n      pasteApi.smarts = pasteApi.smarts || newSmarts();\n      pasteApi.smarts.related.push({\n        api,\n        relation: newPaste,\n        group,\n        title: api.title || newPaste.title\n      });\n    }\n\n    return newPaste;\n  });\n}\n\nfunction findApiByIdInGroups(id, groups) {\n  const findApiGroup = (result, group) => {\n    if (result) {\n      return result;\n    }\n\n    if (group.apis) {\n      const found = group.apis.find(iApi => iApi._id === id);\n\n      if (found) {\n        return found;\n      }\n    }\n\n    if (group.groups) {\n      return group.groups.reduce(findApiGroup, result);\n    }\n  };\n\n  return groups.reduce(findApiGroup, undefined);\n}\n\nfunction findApiGroup(groups, api) {\n  const findApiGroup = (result, group) => {\n    if (result) {\n      return result;\n    }\n\n    if (group.apis) {\n      const found = group.apis.find(iApi => iApi === api || api._id && iApi._id === api._id);\n\n      if (found) {\n        return group;\n      }\n    }\n\n    if (group.groups) {\n      return group.groups.reduce(findApiGroup, result);\n    }\n  };\n\n  return groups.reduce(findApiGroup, undefined);\n}\n\nfunction makePasteSmart(paste) {\n  if (paste.valueMatches) {\n    paste.valueMatches.forEach(item => {\n      if (!item.valueKey) {\n        item.valueKey = paste.valueKey;\n      }\n    });\n  }\n\n  if (paste.valueKey == undefined && paste.value == undefined) {\n    const err = new Error('Issue exists with paste');\n    err.paste = paste;\n    throw err;\n  }\n\n  if (paste.pastes) {\n    paste.pastes.forEach(pasteChild => makePasteSmart(pasteChild));\n  }\n\n  return paste;\n}\n\nfunction paramRequestUrlParams(request) {\n  const identifiers = (0, app_component_utils_1.getStringIdentifiers)(request.path);\n  const interps = (0, app_component_utils_1.getStringInterpolations)(request.path);\n\n  if (interps.length) {\n    request.params = request.params || {}; // create data points for path interps\n\n    interps.forEach(result => {\n      const nameString = result[0];\n      const name = nameString.slice(2, nameString.length - 1);\n      request.params[name] = request.params[name] || '';\n    });\n  }\n\n  if (identifiers.length) {\n    request.params = request.params || {}; // create data points for path identifiers\n\n    identifiers.forEach(result => {\n      const nameString = result[0];\n      const name = nameString.slice(2, nameString.length); // remove /:\n\n      request.params[name] = request.params[name] || '';\n    });\n  }\n}\n\nfunction simpleMenuToSmart(menu) {\n  return Object.entries(menu).reduce((end, [key, value]) => {\n    end[key] = simpleRouteToSmart(value, []);\n    return end;\n  }, menu);\n}\n\nexports.simpleMenuToSmart = simpleMenuToSmart;","map":null,"metadata":{},"sourceType":"script"}