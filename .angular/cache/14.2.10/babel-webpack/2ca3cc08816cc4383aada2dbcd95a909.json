{"ast":null,"code":"var __spreadArray = this && this.__spreadArray || function (to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n    if (ar || !(i in from)) {\n      if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n      ar[i] = from[i];\n    }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n};\n\nexport function method(ob) {\n  return new jXObject(ob);\n}\n\nvar jXObject = function () {\n  function jXObject(object) {\n    this.toCookieString = function () {\n      var cookies = this.object;\n      var cookieNameArray = Object.keys(cookies);\n\n      if (cookieNameArray.length) {\n        var cookieString = '';\n        cookieNameArray.forEach(function (name, i) {\n          cookieString += '; ' + name + '=' + cookies[name];\n        });\n        cookieString = cookieString.substring(2, cookieString.length);\n        return cookieString;\n      }\n\n      return '';\n    };\n\n    this.object = object;\n    return this;\n  }\n\n  jXObject.prototype.forEach = function (method) {\n    forEach(this.object, method);\n    return this;\n  };\n\n  jXObject.prototype.assign = function () {\n    var args = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n\n    assign.apply(assign, __spreadArray([this.object], args, true));\n    return this;\n  };\n\n  jXObject.prototype.deepAssign = function () {\n    var args = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n\n    deepAssign.apply(deepAssign, __spreadArray([this.object], args, true));\n    return this;\n  };\n\n  jXObject.prototype.map = function (method) {\n    return map(this.object, method);\n  };\n\n  jXObject.prototype.isArray = function () {\n    return isArray(this.object);\n  };\n\n  jXObject.prototype.getTypeMap = function (mapper) {\n    var type = typeof this.object;\n    var isObject = type == 'object';\n\n    mapper = mapper || function (type, subs, name) {\n      if (subs) {\n        if (type == 'array') return [subs];\n        return subs;\n      }\n\n      return type;\n    };\n\n    if (!isObject) return mapper(type);\n    var isArray = this.isArray();\n    var uniqueMap = isArray ? [] : {};\n    this.map(function (item, index, object) {\n      if (item === null) return 'null';\n      var subType = typeof item;\n      var isSubOb = subType == 'object';\n      var jxSub = new jXObject(item);\n      var isSubArray = isSubOb && jxSub.isArray();\n      var subs = jxSub.getTypeMap(mapper);\n\n      if (isArray) {\n        if (isSubArray) {\n          subType = 'array';\n          uniqueMap[index] = mapper(subType, subs[0], index);\n        } else if (isSubOb) {\n          if (!uniqueMap[0]) {\n            uniqueMap[0] = mapper(subType, subs, index);\n          } else {\n            deepAssign(uniqueMap[0], mapper(subType, subs, index));\n          }\n        }\n      } else {\n        if (isObject && isSubOb) {\n          if (isSubArray) {\n            subType = 'array';\n            uniqueMap[index] = mapper(subType, subs[0] || {}, index);\n          } else {\n            uniqueMap[index] = uniqueMap[index] || {};\n            uniqueMap[index] = deepAssign(uniqueMap[index], mapper(subType, subs, index));\n          }\n        } else {\n          uniqueMap[index] = mapper(subType, undefined, index);\n        }\n      }\n    });\n    return uniqueMap;\n  };\n\n  jXObject.prototype.isCyclic = function () {\n    var seenObjects = [];\n\n    function detect(obj) {\n      if (obj && typeof obj === 'object') {\n        if (seenObjects.indexOf(obj) !== -1) {\n          return true;\n        }\n\n        seenObjects.push(obj);\n\n        for (var key in obj) {\n          if (obj.hasOwnProperty(key) && detect(obj[key])) {\n            return true;\n          }\n        }\n      }\n\n      return false;\n    }\n\n    return detect(this.object);\n  };\n\n  return jXObject;\n}();\n\nexport { jXObject };\n\nfunction map(ob, method) {\n  if (ob.constructor && ob.contructor == Array) {\n    return mapArray(ob, method);\n  }\n\n  var res = {};\n\n  for (var x in ob) {\n    res[x] = method(ob[x], x, ob);\n  }\n\n  return res;\n}\n\nfunction mapArray(ob, method) {\n  var res = [];\n\n  for (var x = 0; x < ob.length; ++x) {\n    res[x] = method(ob[x], x, ob);\n  }\n\n  return res;\n}\n\nfunction forEach(ob, method) {\n  if (ob.constructor == Array) {\n    for (var x in ob) {\n      method(ob[x], x, ob);\n    }\n  } else {\n    for (var x_1 = 0; x_1 < ob.length; ++x_1) {\n      method(ob[x_1], x_1, ob);\n    }\n  }\n\n  return ob;\n}\n\nfunction isArray(ob) {\n  return ob.constructor && ob.constructor == Array;\n}\n\nfunction assign(target, firstSource) {\n  if (target === undefined || target === null) {\n    throw new TypeError('Cannot convert first argument to object');\n  }\n\n  var to = Object(target);\n\n  for (var i = 1; i < arguments.length; i++) {\n    var nextSource = arguments[i];\n\n    if (nextSource === undefined || nextSource === null) {\n      continue;\n    }\n\n    var keysArray = Object.keys(Object(nextSource));\n\n    for (var nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex++) {\n      var nextKey = keysArray[nextIndex];\n      var desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);\n\n      if (desc !== undefined && desc.enumerable) {\n        to[nextKey] = nextSource[nextKey];\n      }\n    }\n  }\n\n  return to;\n}\n\nfunction deepAssign(target, firstSource) {\n  if (target === undefined || target === null) {\n    throw new TypeError('Cannot convert first argument to object');\n  }\n\n  var to = Object(target);\n\n  for (var i = 1; i < arguments.length; i++) {\n    var nextSource = arguments[i];\n\n    if (nextSource === undefined || nextSource === null) {\n      continue;\n    }\n\n    var keysArray = Object.keys(Object(nextSource));\n\n    for (var nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex++) {\n      var nextKey = keysArray[nextIndex];\n      var desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);\n\n      if (desc !== undefined && desc.enumerable) {\n        if (nextSource[nextKey] != null && typeof nextSource[nextKey] == 'object') {\n          if (nextSource[nextKey].constructor == Array) {\n            to[nextKey] = duplicateArray(nextSource[nextKey]);\n          } else {\n            to[nextKey] = to[nextKey] || {};\n            deepAssign(to[nextKey], nextSource[nextKey]);\n          }\n        } else {\n          to[nextKey] = nextSource[nextKey];\n        }\n      }\n    }\n  }\n\n  return to;\n}\n\nfunction duplicateArray(a) {\n  return a.map(function (v, i) {\n    switch (typeof v) {\n      case 'object':\n        {\n          if (v.constructor === Array) {\n            return duplicateArray(v);\n          }\n\n          return deepAssign({}, v);\n        }\n    }\n\n    return v;\n  });\n}","map":null,"metadata":{},"sourceType":"module"}