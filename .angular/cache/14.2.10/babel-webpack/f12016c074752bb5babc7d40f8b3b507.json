{"ast":null,"code":"var jXMethod = function () {\n  function jXMethod(method, name) {\n    this.method = method;\n    this.name = name;\n    return this;\n  }\n\n  jXMethod.prototype.runInMs = function (ms) {\n    setTimeout(this.method, ms);\n    return this;\n  };\n\n  jXMethod.prototype.getArgNameArray = function () {\n    var string = this.getDefinition();\n    var argDef = /\\(.+\\)/.exec(string)[0];\n    argDef = argDef.substring(1, argDef.length);\n    argDef = argDef.substring(0, argDef.length - 1);\n    argDef = argDef.replace(/\\s|\\t|\\r|\\n/g, '');\n    return argDef.split(',');\n  };\n\n  jXMethod.prototype.getDefinition = function () {\n    var funcNameRegex = /(.*function[^\\)]+\\))/;\n    var results = funcNameRegex.exec(this.method.toString());\n    return results && results.length > 1 ? results[1] : null;\n  };\n\n  jXMethod.prototype.expect = function (nameOrMap, value, requiredOrType, type) {\n    if (nameOrMap && nameOrMap.constructor == String) {\n      return this.expectOne(nameOrMap, value, requiredOrType, type);\n    }\n\n    for (var key in nameOrMap) {\n      var define = nameOrMap[key];\n      var val = define && (define.val !== null || define.value !== null);\n\n      if (val) {\n        val = define.val || define.value;\n        this.expectOne(key, val, define.required, define.type);\n      } else {\n        this.expectOne(key, define, true);\n      }\n    }\n\n    return this;\n  };\n\n  jXMethod.prototype.expectOne = function (name, value, requiredOrType, type) {\n    var isReqDefined = requiredOrType != null && requiredOrType.constructor == Boolean;\n    var isRequired = isReqDefined ? requiredOrType : true;\n    type = type || (isReqDefined ? null : requiredOrType);\n\n    if (isRequired && value == null) {\n      var methodName = this.getName();\n      var methodMsg = methodName ? 'The function ' + methodName + ' recieved an invalid argument. ' : '';\n      var argTypeMsg = methodMsg + 'Argument ' + name + ' is required. ';\n      var err = new Error(argTypeMsg + ' Function definition: ' + this.getDefinition());\n      err[\"invalidArg\"] = {\n        errorType: 'undefined',\n        name: name\n      };\n      throw err;\n    }\n\n    if (type) {\n      if (value != null && value.constructor != type) {\n        var methodName = this.getName();\n        var methodMsg = methodName ? 'The function ' + methodName + ' recieved an invalid argument. ' : '';\n        var argTypeMsg = methodMsg + 'Argument ' + name + ' is not of type ' + type.name + '. ';\n        var err = new Error(argTypeMsg + 'Received type: ' + value.constructor.name + '. Function definition: ' + this.getDefinition());\n        err[\"invalidArg\"] = {\n          errorType: 'type',\n          name: name\n        };\n        throw err;\n      }\n    }\n\n    return this;\n  };\n\n  jXMethod.prototype.getName = function () {\n    var name = this.name || (this.method.name.length ? this.method.name : null);\n    return name || this.getOldSchoolName();\n  };\n\n  jXMethod.prototype.getOldSchoolName = function () {\n    var funcNameRegex = /function\\s+(.{1,})\\(/;\n    var results = funcNameRegex.exec(this.method.toString());\n    return this.name || (results && results.length > 1 ? results[1] : null);\n  };\n\n  return jXMethod;\n}();\n\nexport { jXMethod };\nexport function method(path) {\n  return new jXMethod(path);\n}","map":null,"metadata":{},"sourceType":"module"}